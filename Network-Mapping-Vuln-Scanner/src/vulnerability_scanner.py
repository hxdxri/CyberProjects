#!/usr/bin/env python3
"""
Vulnerability Scanner
Automatically scans all ports and services for vulnerabilities using Nmap NSE scripts
"""

import subprocess
import csv
from datetime import datetime
import os
import json

def run_service_scan(target: str) -> list:
    """Run initial service scan to discover open ports and services."""
    try:
        # Run Nmap with service detection and -Pn flag
        cmd = ['nmap', '-Pn', '-sV', target]
        print(f"Running Nmap command: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # Debug: Print raw Nmap output
        print("\nRaw Nmap output:")
        print(result.stdout)
        
        services = parse_service_scan(result.stdout)
        print(f"\nParsed services: {services}")
        return services
    except Exception as e:
        print(f"Error during service scan of {target}: {str(e)}")
        return []

def parse_service_scan(output: str) -> list:
    """Parse Nmap service scan output to get ports and services."""
    services = []
    print("\nParsing service scan output...")
    for line in output.split('\n'):
        if '/tcp' in line and 'open' in line:
            parts = line.split()
            print(f"Found open port line. Parts: {parts}")
            if len(parts) >= 4:
                port = parts[0].split('/')[0]
                state = parts[1]
                service = parts[2]
                version = ' '.join(parts[3:]) if len(parts) > 3 else 'unknown'
                
                service_info = {
                    'port': port,
                    'state': state,
                    'service': service,
                    'version': version
                }
                print(f"Adding service: {service_info}")
                services.append(service_info)
    return services

def run_vuln_scan(target: str, port: str, service: str) -> dict:
    """Run vulnerability scan using appropriate NSE scripts based on service."""
    try:
        # Select appropriate NSE scripts based on service
        scripts = []
        if service.lower() in ['http', 'https']:
            scripts = ['http-vuln-*', 'http-enum', 'http-headers', 'http-auth', 'http-methods']
        elif service.lower() == 'ssh':
            scripts = ['ssh-auth-methods', 'sshv1', 'ssh2-enum-algos']
        elif service.lower() == 'ftp':
            scripts = ['ftp-vuln-*', 'ftp-anon', 'ftp-bounce']
        elif service.lower() == 'smb':
            scripts = ['smb-vuln-*', 'smb-enum-shares', 'smb-security-mode']
        elif service.lower() == 'mysql':
            scripts = ['mysql-vuln-*', 'mysql-enum']
        elif service.lower() == 'postgresql':
            scripts = ['pgsql-vuln-*']
        elif service.lower() == 'telnet':
            scripts = ['telnet-encryption']
        else:
            scripts = ['vuln', 'default', 'safe']  # Default to general vulnerability scripts
        
        print(f"\nScanning {target}:{port} ({service}) for vulnerabilities...")
        
        # Run Nmap with selected scripts
        cmd = ['nmap', '-p', port, '--script', ','.join(scripts), '-oX', '-', target]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # Parse XML output to extract vulnerabilities
        vulns = parse_nmap_xml(result.stdout)
        return vulns
    except Exception as e:
        print(f"Error scanning {target}:{port} for vulnerabilities: {str(e)}")
        return {}

def parse_nmap_xml(xml_output: str) -> dict:
    """Parse Nmap XML output to extract vulnerability information."""
    vulns = {
        'vulnerabilities': [],
        'warnings': [],
        'info': []
    }
    
    # Basic parsing of Nmap output
    for line in xml_output.split('\n'):
        if '<script id=' in line:
            # Extract script name and output
            script_name = line.split('id="')[1].split('"')[0]
            output = line.split('output="')[1].split('"')[0] if 'output="' in line else ''
            
            # Categorize based on script name and output
            if 'vuln' in script_name.lower():
                vulns['vulnerabilities'].append({
                    'script': script_name,
                    'details': output
                })
            elif 'warning' in output.lower():
                vulns['warnings'].append({
                    'script': script_name,
                    'details': output
                })
            else:
                vulns['info'].append({
                    'script': script_name,
                    'details': output
                })
    
    return vulns

def save_vuln_report(target: str, port: str, service: str, vulns: dict, output_file: str):
    """Save vulnerability scan results to a CSV file."""
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    # Get current timestamp
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # Write to CSV
    with open(output_file, 'a', newline='') as csvfile:
        writer = csv.writer(csvfile)
        
        # Write header if file is empty
        if os.path.getsize(output_file) == 0:
            writer.writerow(['IP Address', 'Port', 'Service', 'Vulnerability Type', 
                           'Script Name', 'Details', 'Scan Time'])
        
        # Write vulnerabilities
        for vuln in vulns['vulnerabilities']:
            writer.writerow([
                target,
                port,
                service,
                'Vulnerability',
                vuln['script'],
                vuln['details'],
                timestamp
            ])
        
        # Write warnings
        for warning in vulns['warnings']:
            writer.writerow([
                target,
                port,
                service,
                'Warning',
                warning['script'],
                warning['details'],
                timestamp
            ])

def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Automated Vulnerability Scanner')
    parser.add_argument('--target', required=True, help='Target IP address')
    parser.add_argument('--output', default='reports/vuln_results.csv',
                       help='Output CSV file path (default: reports/vuln_results.csv)')
    
    args = parser.parse_args()
    
    print(f"Starting service scan on {args.target}...")
    services = run_service_scan(args.target)
    
    if not services:
        print("No open ports found.")
        return
    
    print(f"\nFound {len(services)} open ports:")
    for service in services:
        print(f"Port {service['port']}: {service['service']} ({service['version']})")
    
    print("\nStarting vulnerability scans...")
    total_vulns = 0
    total_warnings = 0
    
    for service in services:
        vulns = run_vuln_scan(args.target, service['port'], service['service'])
        
        # Print results for this service
        if vulns['vulnerabilities']:
            print(f"\nVulnerabilities found on port {service['port']}:")
            for vuln in vulns['vulnerabilities']:
                print(f"- {vuln['script']}: {vuln['details']}")
            total_vulns += len(vulns['vulnerabilities'])
        
        if vulns['warnings']:
            print(f"\nWarnings on port {service['port']}:")
            for warning in vulns['warnings']:
                print(f"- {warning['script']}: {warning['details']}")
            total_warnings += len(vulns['warnings'])
        
        # Save results to CSV
        save_vuln_report(args.target, service['port'], service['service'], vulns, args.output)
    
    print(f"\nScan completed!")
    print(f"Total vulnerabilities found: {total_vulns}")
    print(f"Total warnings: {total_warnings}")
    print(f"Results saved to {args.output}")

if __name__ == "__main__":
    main() 