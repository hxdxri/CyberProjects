#!/usr/bin/env python3
"""
Vulnerability Scanner
Uses Nmap NSE scripts to detect vulnerabilities based on service scan results
"""

import subprocess
import csv
from datetime import datetime
import os
import json

def run_vuln_scan(target: str, port: str, service: str) -> dict:
    """Run vulnerability scan using appropriate NSE scripts based on service."""
    try:
        # Select appropriate NSE scripts based on service
        scripts = []
        if service.lower() in ['http', 'https']:
            scripts = ['http-vuln-*', 'http-enum', 'http-headers']
        elif service.lower() == 'ssh':
            scripts = ['ssh-auth-methods', 'sshv1']
        elif service.lower() == 'ftp':
            scripts = ['ftp-vuln-*', 'ftp-anon']
        elif service.lower() == 'smb':
            scripts = ['smb-vuln-*', 'smb-enum-shares']
        else:
            scripts = ['vuln']  # Default to general vulnerability scripts
        
        # Run Nmap with selected scripts
        cmd = ['nmap', '-p', port, '--script', ','.join(scripts), '-oX', '-', target]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # Parse XML output to extract vulnerabilities
        vulns = parse_nmap_xml(result.stdout)
        return vulns
    except Exception as e:
        print(f"Error scanning {target}:{port} for vulnerabilities: {str(e)}")
        return {}

def parse_nmap_xml(xml_output: str) -> dict:
    """Parse Nmap XML output to extract vulnerability information."""
    vulns = {
        'vulnerabilities': [],
        'warnings': [],
        'info': []
    }
    
    # Basic parsing of Nmap output
    for line in xml_output.split('\n'):
        if '<script id=' in line:
            # Extract script name and output
            script_name = line.split('id="')[1].split('"')[0]
            output = line.split('output="')[1].split('"')[0] if 'output="' in line else ''
            
            # Categorize based on script name and output
            if 'vuln' in script_name.lower():
                vulns['vulnerabilities'].append({
                    'script': script_name,
                    'details': output
                })
            elif 'warning' in output.lower():
                vulns['warnings'].append({
                    'script': script_name,
                    'details': output
                })
            else:
                vulns['info'].append({
                    'script': script_name,
                    'details': output
                })
    
    return vulns

def save_vuln_report(target: str, port: str, service: str, vulns: dict, output_file: str):
    """Save vulnerability scan results to a CSV file."""
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    # Get current timestamp
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # Write to CSV
    with open(output_file, 'a', newline='') as csvfile:
        writer = csv.writer(csvfile)
        
        # Write header if file is empty
        if os.path.getsize(output_file) == 0:
            writer.writerow(['IP Address', 'Port', 'Service', 'Vulnerability Type', 
                           'Script Name', 'Details', 'Scan Time'])
        
        # Write vulnerabilities
        for vuln in vulns['vulnerabilities']:
            writer.writerow([
                target,
                port,
                service,
                'Vulnerability',
                vuln['script'],
                vuln['details'],
                timestamp
            ])
        
        # Write warnings
        for warning in vulns['warnings']:
            writer.writerow([
                target,
                port,
                service,
                'Warning',
                warning['script'],
                warning['details'],
                timestamp
            ])

def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Vulnerability Scanner')
    parser.add_argument('--target', required=True, help='Target IP address')
    parser.add_argument('--port', required=True, help='Port to scan')
    parser.add_argument('--service', required=True, help='Service running on port')
    parser.add_argument('--output', default='reports/vuln_results.csv',
                       help='Output CSV file path (default: reports/vuln_results.csv)')
    
    args = parser.parse_args()
    
    print(f"Scanning {args.target}:{args.port} ({args.service}) for vulnerabilities...")
    vulns = run_vuln_scan(args.target, args.port, args.service)
    
    # Print results
    if vulns['vulnerabilities']:
        print("\nVulnerabilities found:")
        for vuln in vulns['vulnerabilities']:
            print(f"- {vuln['script']}: {vuln['details']}")
    
    if vulns['warnings']:
        print("\nWarnings:")
        for warning in vulns['warnings']:
            print(f"- {warning['script']}: {warning['details']}")
    
    if not vulns['vulnerabilities'] and not vulns['warnings']:
        print("\nNo vulnerabilities or warnings found.")
    
    # Save results to CSV
    save_vuln_report(args.target, args.port, args.service, vulns, args.output)
    print(f"\nResults saved to {args.output}")

if __name__ == "__main__":
    main() 